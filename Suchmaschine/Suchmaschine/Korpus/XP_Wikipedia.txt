Extreme Programming (XP; auch Extremprogrammierung) ist eine Methode, die das Lösen einer Programmieraufgabe in den Vordergrund der Softwareentwicklung stellt und dabei einem formalisierten Vorgehen geringere Bedeutung zumisst. Diese Vorgehensweise definiert ein Vorgehensmodell der Softwaretechnik, das sich den Anforderungen des Kunden in kleinen Schritten annähert. Die Wirksamkeit des Ansatzes ist umstritten (siehe Abschnitt Kritik).


Geschichte

Extreme Programming wurde von Kent Beck, Ward Cunningham und Ron Jeffries während ihrer Arbeit im Projekt Comprehensive Compensation System bei Chrysler zur Erstellung von Software entwickelt. Die Arbeiten am sogenannten C3-Projekt begannen 1995 und wurden 2000 nach der Übernahme durch Daimler eingestellt. Die dabei entwickelte Software wurde im Bereich der Lohnabrechnung eingesetzt.[1]
Grundlagen
XP Lebenszyklus

XP ist ein durch fortlaufende Iterationen und den Einsatz mehrerer Einzelmethoden strukturierendes Vorgehensmodell. XP entstand durch die Synthese verschiedener Disziplinen der Softwareentwicklung und basiert auf in der Praxis bewährten Methoden, auch Best Practices genannt.

XP folgt einem strukturierten Vorgehen und stellt die Teamarbeit, Offenheit und stete Kommunikation zwischen allen Beteiligten in den Vordergrund. Kommunikation ist dabei eine Grundsäule.

Die Methode geht davon aus, dass der Kunde die Anforderungen an die zu erstellende Software zu Projektbeginn noch nicht komplett kennt und nicht hinreichend strukturieren kann beziehungsweise das mit der Realisierung betraute Entwicklerteam nicht über alle Informationen verfügt, um eine verlässliche Aufwandsschätzung über die notwendige Dauer bis zum Abschluss zu geben. Im Laufe eines Projektes ändern sich nicht selten Prioritäten und Gewichte. Zu Beginn geforderte Funktionen der Software werden möglicherweise in einer anderen Form benötigt oder im Laufe der Zeit sogar komplett hinfällig.

Bei einer konsequenten Ausrichtung an XP soll die zu erstellende Software schneller bereitgestellt werden sowie eine höhere Softwarequalität und Zufriedenheit des Kunden als mit traditionellen Ansätzen zu erreichen sein. Der Kunde soll ein einsatzbereites Produkt erhalten, an dessen Herstellung er aktiv teilgenommen hat.

Neue Funktionalität wird permanent entwickelt, integriert und getestet. Um zu der zu entwickelnden Funktionalität zu gelangen, werden jeweils die Schritte Risikoanalyse, Nutzenanalyse, die Bereitstellung einer ersten ausführbaren Version (Prototyping) und ein Akzeptanztest durchgeführt.
Nutzen

Nach Vertretern dieses Vorgehensmodells ist XP Risikomanagement. Es bejaht das Risiko, geht aktiv darauf ein und versucht, es zu minimieren. Dieser implizite Umgang mit dem Faktor Risiko steht im Gegensatz zu eher expliziten Vorgehensweisen, wie der Aufstellung einer Risikoliste.[2] Softwareentwicklungsprojekte sind unterschiedlichen Gefahren ausgesetzt, für die Extreme Programming Lösungen anbieten soll.
Kundensicht

Dem Kunden bietet XP, gerade durch seine kurzen Entwicklungszyklen, jederzeit die Möglichkeit, steuernd auf das Projekt einzuwirken. Dadurch soll erreicht werden, dass sich das Produkt aktuellen Anforderungen anpasst, statt überholten Anforderungen aus einer längst vergangenen Analysephase zu genügen und damit bereits bei Einführung veraltet zu sein. Zudem kann der Kunde bereits nach kurzer Zeit ein unvollständiges aber zumindest funktionstüchtiges Produkt einsetzen. Der Kunde ist im besten Fall jederzeit auf demselben aktuellen Informationsstand bezüglich des Projektes wie das Entwicklerteam.

Ein häufiger Ansatz traditioneller Softwareerstellung ist: „Vielleicht brauchen wir irgendwann einmal diese oder jene Programmfunktionen“, auch Feature genannt. XP stellt dem gegenüber: Lass es! (vgl. auch YAGNI –„You Ain’t Gonna Need It”)). Vor jedem der kurzen Entwicklungsschritte wird zusammen mit dem Kunden genau festgelegt, was wirklich sinnvoll ist entwickelt zu werden. Die so genannte „Featuritis“ soll damit vermieden werden.

Eines der größten Risiken der Softwareentwicklung ist, dass dem Kunden ein Produkt bereitgestellt wird, das er in dieser Form nicht möchte. XP möchte dem durch ständige, aktive Einbeziehung des Kunden in den Entwicklungsprozess vorbeugen. Er kann sich Zwischenversionen ansehen und direkt Änderungswünsche äußern.

Um diese Vorteile nutzen zu können, muss der Kunde im Gegenzug auch eine Reihe von Einschränkungen und Forderungen hinnehmen. So fordert XP von ihm, dass er während der gesamten Entwicklungszeit mit dem Entwicklungsteam zusammenarbeitet. Des Weiteren muss er auf eine formale Festlegung der Projektinhalte (Spezifikation) verzichten (siehe auch Der ideale Kunde).
Programmierersicht

Es existiert keine strikte Rollentrennung, da die Aufgabenverteilung abhängig von Situation und Fähigkeiten geschieht. Der allgemeine Wissensaustausch und die stetige Kommunikation beugen einem Wissensmonopol vor. Dies soll den Einzelnen entlasten, wohingegen der Druck auf einer Person lastet, wenn diese sich als Einzige in einem Modul auskennt.

Um Unbenutzbarkeit aufgrund von Programmfehlern sowie fehlerhafte Integration einzelner Komponenten zu vermeiden, werden bei XP viele und möglichst frühe Tests angestrebt. Jede Komponente besitzt einen Modultest (Unit-Test); in Java beispielsweise mit JUnit. Bei Feststellung eines Fehlers in einer Komponente während der Entwicklung wird ein Test entwickelt, der diesen lokalisiert. Eine tägliche Einbeziehung der einzelnen am Projekt beteiligten Entwickler mit automatischer Ausführung der Tests (Regressionstest) soll zu einer erheblichen Qualitätssteigerung führen. Fehler sollen so früher gefunden werden, denn je später ein Fehler gefunden wird, desto teurer ist meist dessen Korrektur. Außerdem soll die testgetriebene Entwicklung zu einem leichter wartbaren Programmcode mit besserem Design führen.

Da die meisten Einzelmethoden gerade auf den Alltag der Programmierer ausgerichtet sind, bedeutet XP zugleich auch ein hohes Maß an Herausforderung und ggf. Umstellung der Beteiligten. Auf diese Aspekte wird ausführlicher im Abschnitt Der ideale Programmierer eingegangen.
Projektsicht

Dem Projekt bietet XP die Möglichkeit, Risiken zu minimieren. Unter richtiger Anwendung von XP soll der Kunde Software erhalten, deren Umfang ihn nicht überrascht. Das Team soll ferner gegen Ausfall (Krankheit, Unfall, Stellenwechsel) Einzelner nicht mehr so anfällig sein. Ein ehrlicher Umgang mit dem Kunden soll die Glaubwürdigkeit und Zufriedenheit steigern und die Angst minimieren, die unter Umständen zwischen Kunde („Haben die mich verstanden?“, „Was werden sie wohl liefern?“) und Entwicklung („Was will er eigentlich genau?“, „Ob er zufrieden sein wird mit dem, was wir liefern?“) vorherrscht.

Aufwandsabschätzungen werden verlässlicher, da sie im Team getroffen und ständig einer kritischen Überprüfung (Review) unterzogen werden. Teamgeist wird laut XP gefördert. Jedem im Team sollte klar sein, dass das Ziel nur als Einheit erreichbar ist. Sollte ein Projekt, zum Beispiel aus Kostengründen, vorzeitig eingestellt werden, besteht durch die regelmäßigen Iterationen dennoch ein zumeist einsatzfähiges Produkt.

In vielen Projekten gelingt es nicht, das Produkt in der gewünschten Zeit im gewünschten Umfang und mit den geplanten Ressourcen fertigzustellen. In XP soll nur das verwirklicht werden, was tatsächlich einen Nutzen für den Kunden hat. Durch ständigen Austausch mit dem Kunden sowie Prioritätsanalysen sollen die unbedingt zu erstellenden Funktionen identifiziert werden. Dabei sollte mit den Funktionen begonnen werden, die den größten Nutzen haben und das größte (technische) Risiko beinhalten.
Betriebswirtschaftliche Sicht

Extreme Programming stellt aus wirtschaftswissenschaftlicher Sicht eine Form der Organisation dar, die direkt die Prozesse der Wertschöpfung beschreibt. In den Wirtschaftswissenschaften werden zur Bewertung von Extreme Programming auch Erkenntnisse anderer Sozialwissenschaften, insbesondere der Soziologie, genutzt.

Dem Risikomanagement dient diese Alternative vor allem zur Steuerung von Risiken. Wie bei vielen Prozessen der Wertschöpfung sind besonders in der Softwareentwicklung Risiken meist operative Risiken: Die Wertschöpfung ist ineffektiv, wenn die Kundenwünsche nicht getroffen und gesteckte Ziele somit verfehlt wurden. Die Wertschöpfung ist ineffizient, wenn zum Erreichen des Ergebnisses ein zu hoher Aufwand entstand. Risikoverminderung, und dadurch Effektivität und Effizienz, soll bei Extreme Programming durch die Art des Umgangs mit Fehlern, mit Mitarbeitern und mit Kunden erreicht werden:

    Kompensation von Krankheitsausfällen
    Kundennahe Entwicklung
    Weniger Fehler im Ergebnis

Ein möglichst genaues Erkennen von Risiken durch das Verfahren selbst soll über angepasste Aufwandsschätzungen eine Bewertung des zu akzeptierenden Risikos ermöglichen. Extreme Programming kann dagegen eine Risikoverlagerung erschweren. Aus der Sicht des Risikomanagements ist Extreme Programming also nur eine Möglichkeit, mit Risiken umzugehen, und zwar eine Möglichkeit, die Vor- und Nachteile besitzt.

Das Personalwesen in Unternehmen betrachtet Extreme Programming insbesondere im Hinblick auf seine Auswirkungen auf die Mitarbeiterzufriedenheit. Extreme Programming soll dabei bewusst oder unbewusst zum kooperativen Lernen beitragen. Für das Personalwesen ist dieses Verfahren also besonders aus Sicht der Personalentwicklung interessant. Durch höhere Mitarbeiterzufriedenheit und durch die Vermeidung von Überstunden soll die gesamte Produktivität erhöht werden. Die Praktik des Pair-Programming lässt allerdings – rein mathematisch betrachtet – Gegenteiliges vermuten. Die Vermeidung von Spezialistentum und individuellem Besitz von Wissen über Teile der Software dient der kollektiven Wissenskonstruktion und kann die Ersetzung von Entwicklern vereinfachen.

Die gesamte Betriebswirtschaftslehre ist in den letzten Jahren von der prozess- bzw. wertschöpfungsorientierten zur kunden- bzw. marktorientierten Unternehmensführung übergegangen. Auch wenn Extreme Programming die Wertschöpfung beschreibt, bietet es Möglichkeiten zu kundennaher Vorgehensweise. Über Extreme Programming soll – wie in anderen Branchen schon länger üblich – eine größere Einbindung des Kunden in den Wertschöpfungsprozess möglich sein. Wichtig wird dies umso mehr, wenn Software weniger als Faktorgut, sondern mehr als Vorprodukt erstellt und vertrieben wird.

Ebenfalls betrachtet werden muss Extreme Programming und dessen Aufwand aus Sicht des Informationsmanagements, das den Aufwand für den unbedingt notwendigen Informationsaustausch festlegt und ökonomisch bewertet. Genutzt werden dazu Erkenntnisse der Informations- und Kommunikationswissenschaft. Dabei kann insbesondere die Medienreichhaltigkeitstheorie eingesetzt werden: Weil die zu diskutierenden und kommunizierenden Sachverhalte in der Regel komplex sind, werden auch komplexe, reichhaltige Kommunikationsmedien gewählt: direkte, persönliche Gespräche. Kritisch zu hinterfragen ist hierbei die schwierige räumliche Verteilbarkeit der Entwicklungsprozesse sowie die Einbindung des Kunden, da unter Umständen eine räumliche Trennung zwischen Entwicklern und Kunden besteht.
Vorgehen

Vereinzelt wird Extreme Programming als informelle (und damit unverbindliche) Methode bezeichnet. Das trifft jedoch weder den Ansatz noch das Ziel. Tatsächlich ist die Formalisierung der Methode des Extreme Programming bewusst flach und schlank gehalten. Hingegen muss ein Einvernehmen zwischen Kunden und Programmierern hinsichtlich der Verbindlichkeit der erstellten Unterlagen hergestellt werden, solange diese noch nicht durch neuere Fassungen ersetzt wurden. Weiter muss der Vorgang des Ersetzens einer Fassung einer Unterlage durch eine neuere Fassung dieser Unterlage soweit formalisiert sein, dass beide Parteien Kenntnis von dieser Ersetzung haben und diese Ersetzung annehmen.
Aufbauorganisation

Neben dem Entwicklungsteam gibt es im Wesentlichen den Kunden und den Product-Owner. Innerhalb des Entwicklerteams soll es keine Rollentrennung geben. So wird nicht unterschieden, wer im Team welches Spezialgebiet hat, beziehungsweise welche besonderen Fähigkeiten er mitbringt. Jede Person im Team wird als Entwickler (Developer) bezeichnet. Ein Manager ist gewöhnlich eine Person mit Führungsbefugnis, also ein disziplinarischer Vorgesetzter. Dieser hat in XP weniger Wichtigkeit. Dagegen gibt es einen „Leiter“ des Teams, also jemand, der die Kommunikation mit Kunden oder untereinander koordiniert. Auch der Nutzer der zu erstellenden Software kann das Team durch das Projekt führen. Die Unterscheidung zwischen Manager und „Leiter“ ist für agile Vorgehensmodelle typisch. Der Product-Owner, der über die genaue Vorgehensweise entscheidet, trägt die Verantwortung. Product-Owner im Sinne von XP kann beispielsweise ein Vertreter des Produktmanagements, ein Kunde oder ein Nutzer des Produktes sein. Die Rollen sind je nach Projekt und Umgebung unterschiedlich, häufig auch in Personalunion, verteilt.
Die Rollen bei XP Rolle 	Beispiel 	Aufgaben
Produktbesitzer 	Produktmanagement, Marketing, ein Benutzer, Kunde, Manager des Benutzers, Analyst, Sponsor 	Hat Verantwortung, setzt Prioritäten, Entscheider für bestes ROI
Kunde 	Auftraggeber, kann auch der Produktbesitzer sein, kann, muss aber nicht der Benutzer sein 	Entscheidet, was gemacht wird, gibt regelmäßig Rückmeldung, Auftraggeber
Entwickler 	Bestandteil des Teams, das ganze Entwicklungsteam besteht aus Entwicklern: Programmierer, Tester, DB-Experten, Architekt, Designer 	Entwickelt das Produkt
Projektmanager 	Ist gewöhnlich der Produktbesitzer. Kann auch Entwickler aber nicht Manager des Teams sein 	Führung des Teams
Benutzer 	Der Nutzer des zu erstellenden Produktes 	Wird das zu erstellende Produkt nutzen
Anforderungsmanagement

Der Umgang mit den Anforderungen und deren Verwirklichung ist eine zentrale Komponente XPs. Durch eine Mischung verschiedener, in den folgenden Abschnitten dargestellter Maßnahmen soll die Qualität und Flexibilität der Software gesteigert werden, so dass sich der Zusammenhang zwischen dem Zeitpunkt der Anforderungsstellung und den damit entstehenden Kosten weitgehend linear darstellt.
Änderungskostenkurve in Abhängigkeit vom Zeitpunkt der Änderung

Bei einem weitgehend linearen Verlauf einer ableitbaren Änderungskostenkurve wird auf eine vollständige Erhebung aller Anforderungen zu Beginn des Projektes verzichtet. Stattdessen werden die sich erst im Laufe der Umsetzung ergebenden Anforderungen berücksichtigt. Dieses Vorgehen resultiert aus den Beobachtungen, dass einerseits der Kunde zu Beginn des Projektes noch gar nicht genau weiß, was er möchte, andererseits sich diese Anforderungen im Laufe eines Projektes ändern. Darüber hinaus sind Fehler umso teurer, je später man sie findet. Im schlimmsten Fall erhält der Kunde nach einem langen Projekt etwas geliefert, was er in dieser Form gar nicht haben möchte. Ständiger Gedankenaustausch mit dem Kunden, Offenheit für Änderungen und stetige Integration wirken diesen Risiken entgegen. Anforderungen werden nicht selten zunächst als Prototypen bereitgestellt. Dabei handelt es sich um Versionen, die noch nicht die volle, endgültige Funktionalität besitzen.
Planung
Release, Iterationen, User-Storys und Tasks

Im Rahmen der Planung wird gewöhnlich folgende Unterscheidung vorgenommen: ein Release beinhaltet die Funktionen, die insgesamt und für sich geschlossen die Bereitstellung einer neuen Version des Produktes rechtfertigen. Um zu dem Release zu kommen, ist ein Release-Plan aufzustellen, der im Wesentlichen aus Iterationen besteht. Unter anderem abhängig von der geschätzten Entwicklungsdauer des Release werden die Iterationen in Anzahl und Dauer festgelegt. Iterationen dauern üblicherweise zwischen einer und vier Wochen. Der Zeitpunkt der Fertigstellung wird als Zeitintervall diskutiert, dessen Größe im Laufe des Release aufgrund gewonnener Erkenntnisse und des durchgeführten Fortschritts ständig abnimmt.
Risiko-Wert Gegenüberstellung und Verteilung der Prioritäten
User-Stories

Die innerhalb der Iterationen umzusetzenden einzelnen Neuerungen werden mit dem Kunden durch User Stories, einer „schlankeren“ Form der Anwendungsfälle (Use Cases), beschrieben. User Stories beschreiben die Funktionsanforderungen an ein System aus Sicht eines Akteurs. Eine User Story folgt dem Muster „Als x kann ich y tun, um z zu erreichen.“ Wobei der um-Zweig auch weggelassen werden kann, falls die dahinter stehende Absicht klar erkennbar ist. Diese Formulierung dient als Vorlage der abzuarbeitenden Anforderungen und ist situationsabhängig änderbar.

Das ganze Team ist bei der Erstellung beteiligt. Die abzuarbeitenden Anforderungen werden auf einzelnen Karten (Story Cards) geschrieben und für alle sichtbar platziert. Neben diesem Vorgehen ist es auch üblich Class Responsibility Collaboration Models auf CRC Cards zu verfassen. CRC Models nehmen sich dabei einen Akteur im System vor und beschreiben dessen Verantwortlichkeiten und Interaktionen mit anderen Akteuren.

Den User Stories werden Prioritätswerte zugeordnet. Dazu muss das Team zusammen mit dem Kunden zunächst Klarheit gewinnen, welche User Stories das höchste Risiko bezüglich Zeitplan, Kosten oder Funktionalität besitzen und welche User Stories dem Produkt den höchsten, respektive den niedrigsten Mehrwert bieten, wobei ein Diagramm hilfreich sein kann. Das Release sollte mit den User Stories begonnen werden, die das höchste Risiko und den höchsten Nutzen auf sich vereinen. Danach sind diejenige User Stories zu verwirklichen, die geringes Risiko aber hohen Nutzen haben. Anschließend geht das Team die User Stories an, die geringes Risiko und geringen Nutzen auf sich vereinen. Die Fertigstellung von User-Storys mit geringem Nutzen aber hohem Risiko ist zu vermeiden.
Kundenzufriedenheit

Neben einer Abschätzung nach Nutzen und Risiko ist für die Entscheidung, welche User Stories in dem Release beziehungsweise in den ersten Iterationen umgesetzt werden sollen, noch eine Analyse der Kundenwünsche von Bedeutung. Dabei bedient sich ein XP-Projekt häufig des Kano-Modells. Dabei werden in einer systematischen Kundenbefragung Fragen in funktionaler Form und in dysfunktionaler Form gestellt. Es lässt sich anschließend bestimmen, welche User Stories unbedingt fertiggestellt werden müssen (Must-haves), welche linearer Natur sind (je mehr, desto besser; siehe linear.) und welche Exciters sind (Der Kunde rechnet nicht mit diesen Merkmalen, nutzt das Produkt auch ohne. Es lässt sich dadurch der Preis erhöhen.). Die so gewonnenen Erkenntnisse werden diskutiert.

XP zeichnet sich dadurch aus, dass die Betrachtung der Größe einer Einheit, wie Release oder Iteration, unabhängig von ihrer Dauer ist.
Aufwandsabschätzung

Bei der Release-Planung sind User-Storys noch recht grobkörnig. Beschäftigt sich ein Team mit einer User-Story genauer, so wird sie, zusammen mit dem Kunden, detaillierter beschrieben. User-Storys werden gewöhnlich in Story-Points abgeschätzt, wobei auch eine Abschätzung in idealen Tagen möglich ist. Story-Points sind relative Aufwandsabschätzungen, also der Entwicklungsaufwand für eine Story im Vergleich zu anderen. Dabei kann es sein, dass erste Abschätzungen im Verlaufe des Projektes geändert werden. Es wird vom ganzen Team, in mehreren Runden, in einem Planning-Game eine Punkteanzahl für die User-Storys geschätzt.

Nachdem User-Storys abgeschätzt, priorisiert und einer Iteration zugewiesen wurden, beginnt das Team mit der Umsetzung. User-Storys werden zu Beginn der Iteration in feinkörnige, technische Arbeitspakete (Tasks) zerlegt, die gewöhnlich einen Umfang von Stunden besitzen. Das Team führt diese Zerlegung durch und schätzt die Dauer eines jeden Tasks. Es wird allerdings noch nicht festgelegt wer den Task zugeteilt bekommt. Zu Beginn der Arbeiten nehmen sich die Entwickler jeweils ein Arbeitspaket vor, gewöhnlich nach Fähigkeiten. Dieser Vorgang wird im Team kurz diskutiert. Nach der anfänglichen Zuweisung der Arbeitspakete wird ein weiterer Task begonnen, wenn ein Teammitglied Zeit dafür findet, also seinen vorangegangenen Task abgeschlossen hat. Die Implementierung einer User-Story, also der Funktionalität, ist erst abgeschlossen, wenn alle einzelnen Tasks dieser User-Story abgearbeitet und die Tests geschrieben und alle erfolgreich durchlaufen sind.

Der Demonstration dieser Vorgehensweise soll eine Tabelle mit Aufwandsabschätzungen in einer fiktiven Arztpraxis dienen. Jeder Arzt hat eine Software, die ihm hilft, seine Patienten und die Termine zu verwalten:
User-Storys mit Aufwandsabschätzung in Story-Points Story No. 	Story 	Abschätzung
(Story Points)
1 	Als Arzt kann ich alle Patienten sehen, die ich am Tage habe. 	3
2 	Als Arzt kann ich über die Gesundheitsgeschichte meiner Patienten Auskunft geben. 	5
3 	Als Assistentin kann ich einem Patienten einen Termin geben. 	2
4 	Als Assistentin kann ich einem Patienten eine Verschreibung ausdrucken. 	1

Der Begriff Velocity (Geschwindigkeit) beschreibt den Durchsatz des Teams, also die Anzahl der innerhalb einer Iteration erreichten Story-Points. Die Bestimmung der Velocity hilft abzuschätzen, wie lange die Entwicklung der gewünschten Funktionalität für ein Release dauert, beziehungsweise wie viele Iterationen notwendig sind. Es ist normal, dass die Geschwindigkeit des Teams nicht immer die gleiche ist.
Entwicklung und Abschluss
XP-Kreislauf (Loop): Welche Schritte in welchen zeitlichen Abständen.

Es gibt eine tägliche kurze Besprechung (Stand-up Meeting), bei der jeder Entwickler berichtet, was er am Vortag geleistet hat, wo es gegebenenfalls Probleme gab und was er heute leisten möchte. Ferner werden situationsabhängig Arbeitspaare gebildet (Pair-Programming). Im Laufe des Tages findet, während die Entwickler die Funktionalität und die Tests programmieren, weiterer stetiger Austausch (Pair-Negotiations) statt.

Kann eine User-Story in einer Iteration nicht abgeschlossen werden, zum Beispiel weil die Tests nicht erfolgreich waren oder sich die Abschätzung als zu knapp beziehungsweise der Umfang als zu groß herausgestellt hat, so wird sie gewöhnlich in mehrere kleinere aufgeteilt oder komplett in die nächste Iteration verschoben. Auch während einer Iteration kann sich, durch sich ändernde Prioritäten des Kunden oder durch neue Erkenntnisse, an der Zusammenstellung der Iteration etwas ändern. Ist die Iteration abgeschlossen, schauen sich Vertreter des Managements, der Kunde (Akzeptanztest) oder andere Personen, die an dem Produkt Interesse haben, das Produkt in der aktuellen Ausbaustufe an und geben Rückmeldungen. So ist es denkbar, dass der Kunde während des Akzeptanztests neue Prioritäten setzt oder weitere Ideen einbringt.

Technische Unterstützung muss differenziert betrachtet werden. Einerseits wird bewusst auf technische Hilfsmittel verzichtet, so etwa bei der Erstellung von User-Storys. Diese werden gewöhnlich manuell erstellt. Andererseits wird die Technik aber auch exzessiv genutzt, so etwa bei der automatisierten Integration und der automatisierten Durchführung von Tests. Darüber hinaus existieren Projektmanagement-Werkzeuge, die sich auf die speziellen Rahmenbedingungen und Anforderungen XPs konzentriert haben.
Abgrenzung von herkömmlichem Vorgehen

Die zu entwickelnde Funktionalität wird kurz und formlos in User-Storys beschrieben. Das meiste Wissen über die Funktionalität ihrer Entwicklung befindet sich in den Köpfen der Beteiligten. User-Storys werden gewöhnlich nur relativ zueinander geschätzt. Zu Beginn einer Iteration wird deren Inhalt festgelegt. Anschließend kommt erst die Aufteilung der gewählten User-Storys in Tasks. Neuartig an dem XP-Ansatz ist ebenfalls, dass nicht nur einzelne Personen, sondern das ganze Team den jeweiligen Aufwand schätzt. Auch das Verfahren der Schätzung ist neu. Der Zeitpunkt, wann und wie die Tasks den einzelnen Entwicklern zugeteilt werden, ist ebenfalls ein Abgrenzungskriterium. Erst im Laufe der Iteration nehmen sich die einzelnen Entwickler, je nach ihrer Verfügbarkeit, eines Tasks an. Zu allen User-Storys gibt es zahlreiche Tests. Eine User-Story ist erst komplett abgeschlossen, wenn alle Tests erfolgreich abgelaufen sind. Der tägliche kurze Austausch ist für die agile Methodik üblich.
Bestandteile

XP besteht aus Werten, Prinzipien und Praktiken. Obwohl es auch andere maßgebliche Quellen gibt (siehe Weblinks und Literatur), orientiert sich die Zusammenstellung der Werte, Prinzipien und Praktiken an Kent Beck,[3] dessen noch recht neue, evolutionäre Weiterentwicklungen XPs hier ebenfalls Berücksichtigung finden.[4] Es existiert keine eindeutige Definition von XP, wobei allerdings die Diskussionen und Ausführungen der drei Originalverfasser XP am signifikantesten prägen.
Werte

XP definiert fünf zentrale Werte, abstrakte Elemente, die von zentraler Bedeutung sind: Kommunikation, Einfachheit, Rückmeldung, Mut und Respekt, wobei Respekt erst später dazukam. Ohne stetige Beachtung dieser zentralen Werte ist es laut XP nicht möglich, erfolgreich Software zu entwickeln.
Die zentralen XP-Werte

Das Team kommuniziert stetig, um Informationen auszutauschen. Der Prozess selbst erfordert hohe Kommunikationsbereitschaft. Es gibt einen stetigen Austausch aller Beteiligten, also auch zwischen dem Entwicklungsteam und dem Kunden. Es kommen auch Personen zu Wort, die in einer gerade diskutierten technischen Aufgabenstellung keine Experten sind. So werden sie miteinbezogen, es gibt zusätzliche Rückmeldungen und jeder fühlt sich dem Team und dem Produkt verpflichtet. Stetige Kommunikation mit dem Kunden, Aufnahme seines Feedbacks und Erfüllung seiner Wünsche, also auch eines lauffähiges Produktes, das seinen Wünschen voll entspricht, ist wichtiger als Vertragsverhandlungen. Die Kommunikation zeichnet sich ferner durch einen respektvollen Umgang aus, sowohl im Team untereinander als auch mit dem Kunden. Unterschiedliche Meinungen werden akzeptiert.

Die Entwickler sollen mutig sein und die Kommunikation offen gestalten. Falls eine Anforderung nicht in einer Iteration umgesetzt werden kann, wird in offener und ehrlicher Art und Weise direkt darauf hingewiesen. Es muss eine Atmosphäre geschaffen werden, die herkömmliche Störungen (wie unnatürlichen Konkurrenzkampf innerhalb des Teams zu Lasten des Produktes) minimiert. Um die Offenheit und den Mut zu fördern und gruppendynamischen, psychologischen Schwierigkeiten entgegenzutreten, kann bewusst ein Doomsayer zur offenen, zeitnahen Aussprache von schlechten Nachrichten oder möglichen Schwierigkeiten oder auch ein Advocatus Diaboli eingesetzt werden.

Es soll die einfachste Lösung für eine Problemstellung umgesetzt werden. In jeder Iteration konzentriert sich das komplette Team genau auf die momentan umzusetzenden Anforderungen. Die Lösungen sind technisch immer möglichst einfach zu halten.
Prinzipien

Es gibt 14 Prinzipien, die eine Brücke bilden zwischen den abstrakten Werten und den konkret anwendbaren Praktiken. Diese Prinzipien sollten immer Berücksichtigung finden. Sie sind Menschlichkeit, Wirtschaftlichkeit, Beidseitiger Vorteil, Selbstgleichheit, Verbesserungen, Vielfältigkeit, Reflexion, Lauf, Gelegenheiten wahrnehmen, Redundanzen vermeiden, Fehlschläge hinnehmen, Qualität, Kleine Schritte sowie Akzeptierte Verantwortung.

Software wird von Menschen entwickelt. Menschen bilden also den Faktor, dem laut XP besondere Aufmerksamkeit gilt. Durch Schaffung einer menschlichen Atmosphäre soll den Grundbedürfnissen der Entwickler (Sicherheit, Vollendung, Identifikation mit der Gruppe, Perspektive und Verständnis) entsprochen werden.

Die erstellte Software beziehungsweise eine einzelne Funktionalität muss einerseits wirtschaftlich sein und dennoch einen echten Wert bringen. Andererseits muss sie für beide Seiten von Vorteil sein und alle Beteiligten (Entwicklungsteam und Kunde) zufriedenstellen.
Die Prinzipien XPs

Die Wiederverwendung bestehender Lösungen, wozu beispielsweise die zahlreichen unterschiedlichen Tests gehören, die stetig automatisiert durchlaufen werden, ist wichtig. Es ist jedem klar, dass erste Lösungen meist nicht optimal sind. Aus Feedback und selbst gewonnenen, neuen Erkenntnissen wird die Lösung stetig verbessert. Immer bessere Lösungen zu erkennen, gelingt nur durch stetige Reflexion und ein kontinuierliches Hinterfragen der jeweiligen Vorgehensweisen im Team. Die Produktivität dieses Verfahrens steigt proportional zur Uneinheitlichkeit des aus Personen mit unterschiedlichen Fähigkeiten und Charakteren bestehenden Teams. Verschiedene Meinungen werden nicht nur geduldet sondern sogar gefördert. Dazu muss ein Konfliktmanagement etabliert werden.

Die Lauffähigkeit der Software muss zu jedem Zeitpunkt garantiert sein. Obwohl kurze Iterationen mit permanentem Feedback dabei helfen, das Projekt in einem Lauf zu halten, müssen Fehlschläge dennoch miteinkalkuliert werden. Es ist durchaus üblich und wird akzeptiert, eine Umsetzung durchzuführen, die zunächst nicht optimal oder sogar fehlerhaft sein kann. Diese Schwierigkeiten müssen als Gelegenheit und Chance begriffen werden, das Produkt und das Team noch weiter reifen zu lassen. Ein offener, konstruktiver Umgang mit den Herausforderungen der Softwareentwicklung gelingt umso besser, je mehr alle Beteiligten bereit sind, ihre Verantwortung zu akzeptieren. Einem Entwickler eine Aktivität und Verantwortung nur disziplinarisch aufzutragen, reicht nicht aus, da er die Verantwortung aktiv annehmen und leben muss.

Ein weiterer wichtiger Punkt ist die hohe Qualität, die gemäß XP im Gegensatz zu anderen Faktoren wie Ressourcen, Funktionsumfang oder Endtermin nicht zur Diskussion steht. Diese Grundeinstellung unterscheidet sich von vielen anderen Methoden der Softwareerstellung, bei denen Software zu einem bestimmten Zeitpunkt und in einem definierten Funktionsumfang fertiggestellt werden soll, worunter fast immer die Softwarequalität leidet. Gerade die Qualität ist allerdings wichtig, um das Produkt einsatzfähig, fehlerfrei und erweiterbar zu halten. Software mit gutem Design und hoher Qualität ist mittelfristig kostengünstiger, erweiterbarer und weniger fehlerbehaftet als schnell erstellte, sogenannte Quick-and-dirty-Software.

Zu guter Qualität gehört auch die Vermeidung von Redundanzen (unnötig mehrfach oder wiederholt ausgeführte oder auch manuell ausgeführte automatisierbare Schritte).

Durch schnelle, kleine Schritte bleibt das Team flexibel und kann sich schnell neuen Rahmenbedingungen anpassen und auf Feedback eingehen. Die negativen Folgen eines einzelnen kleinen, nicht erfolgreichen Schrittes können wesentlich schneller durch einen neuen Schritt kompensiert werden, als dies bei einem einzelnen größeren Schritt der Fall wäre.
Praktiken

Es lassen sich traditionelle und evolutionäre Praktiken unterscheiden. Die traditionellen sind in der XP-Welt weit verbreitet und genutzt. Die evolutionären nehmen verschiedene neue Erkenntnisse aus der jahrelangen Anwendung XPs auf. Sie verfeinern oder modifizieren die ursprünglichen Praktiken geringfügig und machen damit die Nutzung klarer und verständlicher.

XP wird häufig mit den traditionellen Praktiken verbunden, beziehungsweise darauf reduziert.
Traditionelle Praktiken

Pair-Programming
    Bei der Paarprogrammierung teilen sich zwei Programmierer einen Computer – einer codiert (der Driver) und der andere denkt mit und hat das Gesamtbild im Kopf (der Partner). Die Rollen werden regelmäßig getauscht. Dieses Vorgehen steigert den Wissenstransfer. Anfänger sollen schneller von der Arbeit eines Spezialisten lernen. Das Wissen wird verteilt. Das Projekt ist nicht mehr so anfällig gegen den Ausfall eines Einzelnen. Durch ständigen Codereview der Entwicklung und Kommunikation wird das Design verbessert und Fehler schneller gefunden (siehe auch Vier-Augen-Prinzip).
Kollektives Eigentum
    Aktivitäten werden zunächst nicht an einzelne Personen verteilt, sondern an das ganze Team. Es existiert laut Methodik das Bewusstsein und die Verpflichtung nur als Team erfolgreich sein zu können. Einzelne Teammitglieder besitzen kein Wissensmonopol. Pair-Programming und wechselhafte Einsatzgebiete sollen der Strömung entgegenwirken, dass einzelne Personen Teile als ihren Besitz betrachten.
Permanente Integration
    Kontinuierliche Integration der einzelnen Komponenten zu einem lauffähigen Gesamtsystem in kurzen Zeitabständen. Je häufiger integriert wird, desto höher wird laut XP die eintretende Routine. Fehler werden damit früh aufgedeckt. Die mit der Integration verbundenen Kosten sollen fast auf Null minimiert werden, da die Integration zu einem täglichen Schritt gehört, der weitestgehend vollautomatisiert und selbst stabil und durchgetestet sein muss.
Testgetriebene Entwicklung bzw. Permanentes Testen
    Bei der testgetriebenen Entwicklung werden erst die Modultests (Unit-Test) geschrieben, bevor die eigentliche Funktionalität programmiert wird. Der Entwickler befasst sich dadurch früh mit dem Design des Codes und überdenkt seine Programmierarbeit genau. Die Tests werden nach jedem Programmierschritt ausgeführt und liefern Rückmeldung über den Entwicklungsstand. Man spricht in diesem Zusammenhang auch von Grey-Box-Tests. Die Tests sind automatisiert. Im Laufe einer Integration werden Integrationstests durchgeführt. Es wird zwischen Regressionstest und Modultest unterschieden. Während Modultests (Unit-Tests) einzelne Module testen, ist ein Regressionstest die kollektive Ausführung aller Tests, um die unveränderte Lauffähigkeit der alten, bereits vor der Iteration existenten Funktionalität zu überprüfen. Auch Performancetests, bei denen die Leistungs- und Geschwindigkeitsmerkmale in Bezug auf die geforderten Werte gemessen werden, sind üblich. Der Entwickler bekommt Rückmeldung (Feedback), wie viele und welche Tests nicht erfolgreich waren. Ein Akzeptanztest ist die Präsentation des Standes des Produktes, um die Zufriedenheit des Kunden und die Nutzbarkeit zu validieren.

XP Best Practices

Kundeneinbeziehung
    Enge Einbeziehung des Kunden, das heißt der Kunde gibt das Iterationsziel mit einer Auswahl der zu realisierenden User-Storys vor und hat kurz danach die Möglichkeit, Akzeptanztests durchzuführen. Story-Cards dienen als Medium, um die kurzen Anwendungsfälle in Form von User-Storys aufzunehmen. Der Kunde muss immer anwesend oder zumindest erreichbar sein. Neben User-Storys auf Story-Cards existiert noch der Ansatz, CRC-Modelle auf CRC-Karten zu verfassen.
Refactoring
    Laufendes Refactoring, ständige Architektur-, Design- und Code-Verbesserungen, auch um Anti-Patterns umgehend erkennen und beseitigen zu können. XP bejaht die Existenz von Code, der am Beginn nicht perfekt ist. Stattdessen sind sämtliche Teile einem stetigen Review unterworfen. Gefundene, optimierungsfähige Stellen werden gewöhnlich sofort verbessert oder als Fehler (Bugs) definiert, die in einer späteren Iteration behoben werden.
Keine Überstunden
    40-Stunden-Woche, d. h. Überstunden sind zu vermeiden, weil darunter die Freude an der Arbeit, mittelfristig die Konzentrationsfähigkeit der Programmierer und somit auch die Qualität des Produktes leidet. Nachweislich sinkt die Produktivität eines Entwicklers durch Überstunden. Arbeit außerhalb der regulären Arbeitszeit wird im Einzelfall zwar geduldet, aber auf keinen Fall besonders entlohnt oder erwartet. Überstunden zeugen gewöhnlich einfach nur von falscher Planung.
Iterationen
    Kurze Iterationen, um dem Kunden in regelmäßigen Zeitabständen einen lauffähigen Zwischenstand des Produkts zu liefern. Eine Iteration ist eine zeitlich und fachlich in sich abgeschlossene Einheit. Kurze Iterationen und damit verbundene Akzeptanztests erlauben schnelle Feedbackschleifen zwischen Entwicklung und Kunde.
Metapher
    Da in traditionell aufgesetzten Softwareprojekten ein latentes Missverständnis zwischen Kunde und Entwicklungsteam ein häufiges Problem darstellt – der Entwickler hat Schwierigkeiten mit der Fachsprache des Kunden und umgekehrt –, werden die Anforderungen im fachlichen Vokabular des Kunden, idealerweise auch von ihm selbst, in Form von User-Storys beschrieben. Alle sprechen eine Sprache, was durch ein Glossar noch verstärkt werden kann. Es wird eine Metapher gewählt, eine inhaltlich ähnliche, für beide Seiten verständliche Alltagsgeschichte.
Coding-Standards
    Das Team hält sich bei der Programmierarbeit an Standards, welche erst die gemeinschaftliche Verantwortung des Teams bei dieser Aufgabe ermöglichen. Wechselnder Einsatz der Entwickler in allen Bereichen der Software ist laut XP nur durch gemeinsame Standards sinnvoll möglich.
Einfaches Design
    Es soll die einfachste Lösung angestrebt werden, also diejenige, die genau das Gewünschte erreicht (und nicht mehr). Bewusst allgemein (generisch) gehaltene Lösungen oder vorbereitende Maßnahmen für potentiell zukünftige Anforderungen werden vermieden. Zum Thema Einfachheit sind die umgangssprachlichen Akronyme KISS („Keep it small and simple“) und YAGNI („You Ain’t Gonna Need It”) verbreitet.
Planning-Game
    Neue Versionen der Software werden in einem Planning-Game, auch als Planning-Poker bekannt, spezifiziert und der Aufwand zu deren Umsetzung abgeschätzt. An diesem iterativen Prozess sind sowohl Entwicklungsmannschaft als auch Kunde beteiligt.

Evolutionäre Praktiken

Die evolutionären Praktiken wurden fünf Jahre nach den ursprünglichen publiziert und ersetzen diese. Sie lassen sich unterteilen in Hauptpraktiken und ergänzende Begleitpraktiken. Inhaltlich sind die neuen Praktiken mit den alten, traditionellen Praktiken vergleichbar. Die Bezeichnungen der alten Praktiken wurden teilweise modifiziert oder in einzelne Unterpraktiken aufgeteilt. Zwei Praktiken sind weggefallen: die Praktik Metapher war zu schwer zu vermitteln und hat sich laut Literatur nicht durchgesetzt. Coding-Standards werden als selbstverständlich vorausgesetzt und nicht mehr explizit erwähnt.
Hauptpraktiken

Die Hauptpraktiken sind: Räumlich zusammen sitzen, Informativer Arbeitsplatz, Team, Pair-Programming, Energievolle Arbeit, Entspannte Arbeit, Storys, Wöchentlicher Zyklus, Quartalsweiser Zyklus, 10-Minuten-Build, Kontinuierliche Integration, Test-First-Programmierung und Inkrementelles Design.

Durch offene, gemeinsame Anordnung der Arbeitsplätze soll die Kommunikation optimiert werden. Diese Form ist aufgrund der besseren Kommunikationsmöglichkeiten einer räumlichen Trennung der Beteiligten vorzuziehen. Der Arbeitsplatz muss ferner „informativ“ sein, indem zum Beispiel aktuelle Tasks, der Stand des Projektes und andere wichtige Informationen vom Arbeitsplatz aus immer gut sichtbar sind. Empfehlenswert ist es hier zum Beispiel, die User-Storys zentral an einer Wand anzubringen.
Die Hauptpraktiken des evolutionären XPs

Das Team ist laut XP wichtiger als die Individuen. Es fällt, im Bewusstsein, nur als Gemeinschaft erfolgreich zu sein, gemeinsame Entscheidungen. Dies wird dadurch gefördert, dass die einzelnen technischen Aktivitäten in der Planung nicht einzelnen Personen, sondern dem Team zugeordnet werden. Probleme löst das Team ohne den Eingriff eines Managers von außen. Mit dem Thema selbstregulierendes Team befasst sich auch der Essay Die Kathedrale und der Basar. Pair-Programming mit abwechselnden Partnern soll diese Grundeinstellung weiter fördern.

Die Arbeit soll mit voller Motivation und gleichzeitig in einer entspannten, kollegialen Atmosphäre ablaufen, da die Entwickler ohne Überstunden arbeiten und somit maximale Produktivität erreicht wird. Es werden Sicherheitspuffer einkalkuliert. Nicht einhaltbare Versprechen werden vermieden.

Die zu entwickelnde Funktionalität wird in Form von Storys beschrieben, beispielsweise User-Storys. In wöchentlichem Zyklus wird entschieden, welche Kundenwünsche als Nächstes in Angriff genommen werden. Das Projekt selbst wird in einem quartalsweisen Zyklus geplant. Die vorgegebenen Zyklen sind Richtwerte, deren Größen im täglichen Einsatz variieren können.

Die Software zu erstellen und alle Testläufe durchzuführen soll in maximal zehn Minuten abgeschlossen sein. Durch diesen 10-Minuten-Build werden die Kosten für Erstellung und das Testen der Software minimiert. Alle von einem Entwickler gemachten Änderungen sollten circa alle zwei Stunden bereitgestellt werden. Diese kontinuierliche Integration soll einem potentiellen Chaos vorbeugen, das entstehen könnte, wenn die Entwickler ihre Änderungen und Erweiterungen am Produkt selten in das zentrale Datenhaltungssystem (Repository) einstellen würden. Alle Mitarbeiter haben so die Änderungen rasch zur Verfügung. Sowohl die zehn Minuten beim Build als auch die zwei Stunden bei der Integration sind Zielvorgaben, die in konkreten Projekten variieren können. Gerade bei großen Projekten mit einer großen Menge an Quelltext und Entwicklern wird ein Build deutlich länger dauern, und die Integrationsintervalle werden oft größer sein. Die Praktiken betonen nur die Richtung und geben einen Idealwert vor, der angestrebt werden sollte. Durch Automatisierung lässt sich die Build-Zeit weitestgehend minimieren.

Die Entwicklung ist gekennzeichnet durch den Test-First-Programmieransatz: vor der Realisierung der Funktionalität muss der Test geschrieben werden. Ein inkrementelles Design, das neue Erkenntnisse und Feedback aufnimmt, verbessert das Design der Software stetig.
Begleitpraktiken

Die Begleitpraktiken sind:

    richtige Kundeneinbeziehung
    inkrementelles Deployment
    Team-Konstanz
    schrumpfende Teams
    ursachliche Analysen
    geteilter Code
    Codierung und Testen
    eine zentrale Codebasis
    tägliches Deployment
    verhandelbarer, vertraglicher Funktionsumfang
    Zahlen-pro-Nutzung.

Der Kunde nimmt aktiv an der Entwicklung teil. Er ist Teilnehmer an den regelmäßigen Treffen und wird aktiv miteinbezogen. Die Einbeziehung zeigt sich auch beim zu entwickelnden Funktionsumfang, der verhandelbar bleiben muss. Mehrere kleinere Verträge anstatt eines großen Vertrags können in derartig betriebenen Projekten Risiken minimieren und die Flexibilität erhöhen. Da iterativ stetig neue Versionen bereitgestellt werden, muss die finanzielle Kompensation des Kunden unabhängig von der Anzahl der bereitgestellten Versionen sein. Der Kunde zahlt nicht für jede Version der Software, sondern pro Nutzung.
Die Nebenpraktiken des evolutionären XPs

Das Team soll einerseits von seiner Konstanz leben, kann aber auch personell verkleinert werden. Das Entwicklerteam muss über mehrere Projekte hinweg das gleiche sein. Es erwirbt im Rahmen der Produktentwicklung die Fähigkeiten, als Team zusammenzuarbeiten, welche für weitere Projekte genutzt werden kann. Sobald das Team leistungsstärker und produktiver wird, sollte seine Arbeitslast, trotz einer Verlagerung von Ressourcen zu anderen Teams, konstant bleiben.

Dem Code als dem im Zentrum stehenden Medium kommt eine zentrale Rolle zu. Er wird in einer zentralen, datenbankähnlichen Struktur (Repository) gehalten. Es existiert nur eine offizielle Version (Codebasis) des Systems. Dieser Code wird, bildlich gesprochen, zwischen den Entwicklern geteilt. Jeder Entwickler im Team muss in der Lage sein, auch „fremden“ Code jederzeit ändern zu können (Collective-Code-Ownership). Neben dem Code existieren immer die Tests, die zusammen mit dem Code die einzigen zu erstellenden, durch die Entwicklungsarbeit bereitgestellten Medien („Artefakte“) sind. Alle anderen Medien, zum Beispiel die Dokumentation, werden allein aus Code und Tests generiert.

Um Schwierigkeiten früh zu identifizieren, wird inkrementelles Deployment (die Überführung der Anwendung auf das Zielsystem) durchgeführt. Wenn Altsysteme durch neue Software ersetzt werden sollen, muss ein Teil nach dem anderen ersetzt werden. Dieses Vorgehen soll die Umstellung planbarer machen. Das Deployment ist täglich inkrementell durchzuführen. Jeden Tag soll eine neue Version der Software produktiv gestellt werden. Dies macht das Deployment zur Routine, minimiert dessen Kosten und Fehler und ermöglicht stetige Integrations- und Akzeptanztests. Falls einmal ein technisches Fehlverhalten eintritt, muss eine ursächliche Analyse durchgeführt werden.
Flexibilitätsgrad vs. Steifheit

Eine der theoretischen Grundlagen des Extreme Programming ist der Flexibilitätsgrad des zu entwickelnden Softwaresystems. XP geht von einem mindestens proportionalen Zusammenhang zwischen dem Gegenteil der Flexibilität, der sogenannten Steifheit, und den Pflegekosten zur Fehlerbehebung oder Erweiterung des Systems aus. Je flexibler ein Softwaresystem, desto geringer sind die Pflegekosten, je steifer, desto höher.

Einige Steifheitskriterien:

    Die Anzahl überflüssiger bzw. ungenutzter Merkmale
    Eine schlechte, fehlende, schwer verständliche oder zu umfangreiche Dokumentation
    Ein schwer verständlicher oder unflexibler Entwurf
    Fehlende Regressionstests
    Ein schwerfälliges Gesamtsystem

Die Flexibilitätskriterien sind das Gegenteil der Steifheitskriterien, zum Beispiel ein leicht verständlicher und flexibler Entwurf.

Einige der als Bestandteil des Extreme Programming definierten Mechanismen dienen laut XP der Erhöhung der Flexibilität:

    Die testgetriebene Entwicklung sorgt für ein ausreichendes Vorhandensein von Regressionstests und eine verbesserte Testbarkeit der Software
    Das ständige Refactoring führt zur Fehlerbeseitigung, einem leicht verständlichen und flexiblen Entwurf sowie guter Dokumentation
    Die kontinuierliche Integration erfordert zwangsläufig ein leichtgewichtiges Gesamtsystem
    Um die zu entwickelnde Funktionalität zu bestimmen, und zwischen Kunde und Entwicklungsteam auszuarbeiten, werden User-Storys eingesetzt

Ursprung und Abgrenzung

In Abgrenzung von traditionellen Vorgehensmodellen wie dem ab 1970 genutzten Wasserfallmodell, bei dem der Softwareentwicklungsprozess in aufeinanderfolgenden Phasen organisiert wird, durchläuft der Entwicklungsprozess in XP immer wieder iterativ in kurzen Zyklen sämtliche Disziplinen der klassischen Softwareentwicklung (zum Beispiel Anforderungsanalyse, Design, Implementierung, Test). Durch diese inkrementelle Vorgehensweise werden nur die im aktuellen Iterationsschritt benötigten Merkmale verwirklicht (implementiert). XP ist dadurch leichtgewichtiger: Es wird keine komplette technische Spezifikation der zu entwickelnden Lösung vorausgesetzt (so gibt es beispielsweise kein Pflichtenheft).

Nach Jahren der Anwendung von aus heutiger Sicht traditionellen Vorgehensmodellen wie dem Wasserfallmodell haben es, aus Sicht der XP-Vertreter, Projektverantwortliche nur unzureichend verstanden, die Probleme und Risiken der Softwareentwicklung in den Griff zu bekommen. Viele Projekte kamen nie zu einem Abschluss oder überstiegen zeitlich und/oder kostenmäßig die Planung. Viele, gerade über lange Zeiträume laufende Projekte deckten mit Abschluss zwar die zu Beginn spezifizierten Anforderungen ab, berücksichtigten allerdings unzureichend, dass Anforderungen sich ändern können oder erst im Laufe eines Projektes dem Kunden wirklich klar ist, wie das Endergebnis aussehen soll. Über Erfolg und Schwierigkeiten von Softwareprojekten liefert der Chaos-Report von The Standish Group regelmäßig fundierte Untersuchungen, wie beispielsweise 1994.[5]

Die folgende Tabelle stellt den von XP identifizierten Kerndisziplinen den historischen, weitverbreiteten Ansatz mitsamt seinen Risiken der Softwareentwicklung gegenüber. Unternehmen, die XP nicht einsetzen, können Vorgehensmodelle verwenden, die sich – bewusst oder unbewusst – mit diesen Disziplinen positiv auseinandersetzen.
Verbreitete XP-Kerndisziplinen und Risiken bei herkömmlicher Herangehensweise Praktik 	Richtiges Vorgehen nach XP 	Traditionelles oder falsches Vorgehen/Risiko nach XP
Kommunikation 	Stetiger Austausch wird gefördert und erwartet. 	Jeder muss zunächst mal seine Aufgaben lösen.
Mut 	Offene Atmosphäre. 	Angst vor versäumten Terminen und Missverständnissen mit Kunden.
Kollektives Eigentum 	Programmcode, Dokumente etc. gehören dem Team. 	Jeder fühlt sich nur für seine Artefakte verantwortlich.
Pair-Programming 	Zu zweit am Rechner. 	Jeder will und muss zunächst auf seine ihm zugewiesenen Aufgaben schauen.
Integration 	Stetige Integrationen erlauben Feedback und erhöhen Qualität. 	Selten Integrationen, da vermeintlich unnütz und Zeitverschwendung.
Testgetriebene Entwicklung 	Testen hat einen hohen Stellenwert. 	Testen kostet nur Zeit. Wenige manuelle Tests.
Kundeneinbeziehung 	Der Kunde wird zur aktiven Mitarbeit aufgerufen. 	Der Kunde ist selten wirklicher Partner, sondern nur die „andere Seite des Vertrages“.
Refactoring 	Suboptimales Design und Fehler werden akzeptiert. 	Fehler sind verpönt. Erstellte Artefakte laufen angeblich immer direkt perfekt.
Keine Überstunden 	Einhaltung der regulären Arbeitszeit. 	Stetige, regelmäßige Überschreitung der regulären Arbeitszeit.
Iterationen 	Ein Release wird in viele handliche Iterationen unterteilt. 	Iterationen sind nicht nötig, es wird an einem Release gearbeitet.
Stand-up-Meeting 	Täglicher, strukturierter Austausch. 	Große, lange, seltenere Projektmeetings. Die Personenanzahl und der Inhalt sind häufig zu aufgebläht.
Dokumentation 	Wo es sinnvoll ist. 	Wichtiges Artefakt. Alles muss standardisiert dokumentiert sein. Dokumentation wird aber nicht genutzt.
Metapher 	Ein gemeinsames Vokabular. 	Kunde und Entwicklung sprechen in zwei Sprachen, häufig aneinander vorbei.
Team 	Das Team ist wichtig. Es existieren keine Rollen. Feedback wird von jedem erwartet. 	Spezialistentum. Abschottung. Wissensmonopole.
Standards 	Standards, wo es sinnvoll erscheint. 	Überregulierung. Starrer Prozess.
Qualität 	Inhärenter Bestandteil. 	Der Faktor, der als erster vernachlässigt wird, wenn Zeit oder Geld knapp werden.

Der kleinste gemeinsame Nenner aller agilen Vorgehensmodellen ist das „Agile Manifest“:[6]

    Individuen und Interaktionen haben Vorrang vor Prozessen und Werkzeugen
    Lauffähige Software hat Vorrang vor ausgedehnter Dokumentation
    Zusammenarbeit mit dem Kunden hat Vorrang vor Vertragsverhandlungen
    Das Eingehen auf Änderungen hat Vorrang vor strikter Planverfolgung

Neben XP hat auch Scrum einen gewissen Bekanntheitsgrad erlangt. Neben vielen Ähnlichkeiten mit XP gibt Scrum in bestimmten Bereichen Vorgaben bezüglich Iterationslänge, Protokollierung und Verfahren. Scrum nutzt ein eigenes Vokabular.

Eine weitere gerne in diesem Zusammenhang angeführte Disziplin ist das Feature Driven Development, eine Methodik die den Schwerpunkt ebenfalls auf die bereitzustellende Funktionalität legt.

Ähnlichkeiten zwischen XP und Kaizen, einem in Japan vor allem in der Autoindustrie entwickelten Konzept (Kontinuierlicher Verbesserungsprozess) zur Sicherung der Qualität im Fertigungsprozess und einer Optimierung der Fertigungs- und Managementkosten mittels „schlankerer“ Ansätze (Schlanke Produktion), sind nicht zu übersehen.

Ein weiteres agiles Vorgehensmodell ist Crystal, eine Familie von Methoden deren Mitglieder meist mit Farben gekennzeichnet werden.

Aufgrund der wachsenden Nutzung wird XP weiter optimiert: je mehr Projekte gemäß XP entwickelt werden, desto mehr Erfahrungen fließen in die Weiterentwicklung von XP ein. Da es auch eine Summe von Best Practices ist lässt sich somit sagen: „Es wird in der Praxis für die Praxis angepasst“.
XP in Projekten

Heute, über zehn Jahre nach den ersten XP-Schritten, erfreuen sich XP und andere agile Methoden wachsender Beliebtheit. Untersuchungen von „Forrester Research“ ergaben, dass in Nordamerika und Europa 2005 circa 14 Prozent aller Projekte mit agilen Methoden durchgeführt wurden[7] (von denen XP die verbreitetste ist) und viele andere einen Einsatz prüfen.

Zu den Nutzern XPs zählen sowohl Unternehmen, die kommerziell Software herstellen und vertreiben, als auch Unternehmen, deren eigentliches Geschäft nicht die Erstellung von Software ist: Dresdner Kleinwort Wasserstein, Encyclopaedia Britannica, Fidelity, Progressive, Capital One, Royal & Sunalliance, Channel One, Daedalos International, Gemplus, it-agile, Qwest und O&O Services.[8][9]

Viele Unternehmen berichten öffentlich von ihren Erfahrungen mit XP. Sie schildern, wie sie XP im Detail eingesetzt haben, welche Schwierigkeiten dabei auftraten und wie der Erfolg einzuschätzen war. Symantec hat seine Änderung des Vorgehensmodells hin zu XP publiziert[10]. Sabre Airline Solutions hat mit XP sowohl die Fehler in ihrer Software als auch die Entwicklungszeit reduziert:[11]

    “It was XP […] that produced the dramatic quality improvements […] You have the weaker people paired with the stronger people, and business knowledge and coding knowledge are transferred very quickly.”

– Gary Anthes: Sabre[11]
Kritik
	Dieser Abschnitt, einschließlich einiger subjektiver Formulierungen, ist nicht hinreichend mit Belegen (beispielsweise Einzelnachweisen) ausgestattet. Die fraglichen Angaben werden daher möglicherweise demnächst entfernt. Bitte hilf der Wikipedia, indem du die Angaben recherchierst und gute Belege einfügst. Näheres ist eventuell auf der Diskussionsseite oder in der Versionsgeschichte angegeben. Bitte entferne zuletzt diese Warnmarkierung.
Das Alles-oder-Nichts-Prinzip

Gemäß den Protagonisten des XP-Ansatzes wirken die einzelnen Methoden so eng zusammen, dass diese ohne Ausnahme eingesetzt werden sollen. Bereits der Verzicht auf einzelne Methoden kann die Wirksamkeit des Gesamtansatzes massiv einschränken. Da jedoch der Einsatz der Methoden oftmals auf zahlreichen Voraussetzungen basiert (siehe z. B. die Abschnitte Der ideale Kunde und Der ideale Programmierer), ist es wahrscheinlich, dass in konkreten Projekten einzelne Methoden eben gerade nicht angewandt werden können. Das liefert dann auch auf einfache Weise eine Erklärung für das Scheitern von XP-Projekten: Meist dürfte sich eine vernachlässigte Methode finden lassen, so dass das Scheitern nicht auf XP als Gesamtansatz, sondern auf die Vernachlässigung dieser Methode zurückgeführt werden kann.
Bewegliche Anforderungen

Ein Hauptgrund für die Spezifikation von Anforderungen besteht bei klassischen Vorgehensmodellen in der Schaffung einer verlässlichen Basis für die Entwicklungsarbeit, so dass später notwendige Änderungen an der Realisierung möglichst gering bleiben. Die implizite Annahme dieser Haltung ist, dass Änderungen umso teurer werden, je später sie durchgeführt werden müssen. Obwohl sich diese Annahme in vielen Projekten bestätigt hat, geht XP gewissermaßen davon aus, dass Änderungen grundsätzlich „billig“ sind, wenn man sie kontinuierlich durchführt. Auch verneint XP implizit die Annahme, dass spätere Änderungen teurer werden, und begründet dies damit, dass die Änderungen dann nicht – wie in anderen Ansätzen – in mehreren Artefakten zugleich (Spezifikation, Dokumentation, Quellcode) umgesetzt werden müssen.

Die diesbezüglichen Annahmen von XP treffen sicher dann zu, wenn die Anforderungen unvermeidlich Änderungen unterworfen sein werden. In diesem Fall kann eine Spezifikation der Anforderungen unter Umständen größeren Aufwand nach sich ziehen als das Auslassen der Spezifikation – schon allein deswegen, weil die Spezifikation immer mitgeändert werden muss. Es ist jedoch unklar, warum es schädlich sein sollte, Anforderungen zumindest dann zu spezifizieren, wenn sie mit einiger Sicherheit bis zum Projektende Bestand haben werden. Durch den Verzicht auf eine Spezifikation läuft man Gefahr, Anforderungen zu übersehen oder hinsichtlich ihrer Bedeutung falsch einzuschätzen. Auch ist denkbar, dass der Kunde im Projektverlauf seine Anforderungen bewusst ändert, jedoch gegenüber dem Entwicklungsteam bekundet, seine Auffassung sei bislang nur falsch verstanden worden. Hinsichtlich der Einschätzung, dass spätere Änderungen nicht teurer sind als frühe, ist einzuwenden, dass späte Änderungen dann sehr teuer sein können, wenn sie das Design der Anwendung in grundlegender Weise betreffen. So ist die Änderung der Architektur einer Anwendung nicht ohne erheblichen Aufwand durchzuführen, ja sie kann ggf. teurer sein als eine Neuimplementierung. Es ist nicht ersichtlich und erscheint daher als eine Glaubensfrage, ob XP durch den Einsatz seiner Methoden derartige Situationen verhindern kann.
Der ideale Kunde

Der Einsatz von XP verlangt einen experimentierfreudigen Kunden, der nicht nur auf eine Reihe von üblichen Vorgehensweisen verzichten, sondern zudem selbst erhebliche Ressourcen aufwenden muss. Zu den Aspekten, auf die ein Kunde ungern verzichtet, gehören:

Dokumentation
    Software kann in komplexen Systemlandschaften eingeführt werden, so dass unterschiedlichste Beteiligte (z. B. Schnittstellenverantwortliche, Mitarbeiter von externen Providern usw.) Kenntnis von technischen Details erlangen müssen. In solchen Umgebungen verbieten meist schon die Firmenrichtlinien den Verzicht auf eine ausführliche Dokumentation. Aber selbst wenn dies nicht der Fall ist, bleibt zu klären, wie die Kenntnisse über technische Details an die Betroffenen vermittelt werden sollen, wenn keine Dokumentation existiert, und mehr noch, wenn davon ausgegangen werden muss, dass künftige Änderungen die relevanten technischen Einzelheiten betreffen.
Spezifikation
    Insbesondere beim Abschluss von Werkverträgen stellt sich für den Kunden die Frage, worin präzise eigentlich das Gewerk besteht, das durch den vereinbarten Preis erworben wird. Des weiteren können firmenweite Richtlinien die Erstellung einer Spezifikation verlangen.
Termine
    Da der projektleitende Vertreter des Kunden oftmals selbst den Projektfortschritt berichten muss, stellt die Fertigstellung bestimmter Funktionen zu festgelegten Terminen, somit also die Aufstellung eines Projektplans, oftmals einen unverzichtbaren Bestandteil der gemeinsamen Vorgehensweise dar.

Über diese Punkte hinaus stellt das „Kunde vor Ort“-Prinzip eine Anforderung dar, die in der Realität nur äußerst selten umsetzbar ist. Um seine Aufgabe erfüllen zu können, muss der Mitarbeiter offensichtlich über einen erheblichen Wissensumfang verfügen. Ist dies aber der Fall, so ist der Mitarbeiter sehr wahrscheinlich auch in seinem eigenen Unternehmen nicht für mehrere Monate entbehrlich. Nicht selten werden IT-Projekte zudem gerade deshalb an externe Dienstleister vergeben, um den eigenen Ressourcenaufwand zu beschränken. Das „Kunde vor Ort“-Prinzip stellt somit eine der am schwierigsten erfüllbaren Anforderungen des Extreme Programming dar.
Der ideale Programmierer

XP stellt zahlreiche Anforderungen an die beteiligten Programmierer.

    Die Programmierer müssen über sehr gute Fähigkeiten verfügen, da der auf häufigen Änderungen basierende Ansatz unter Verwendung von Refactorings nicht ohne umfangreiche Programmiererfahrung und ohne den Einsatz von dafür geeigneten Werkzeugen realisiert werden kann.
    Programmierer weisen oftmals ein recht ausgeprägtes Ego auf, das sich in großer Überzeugung von „richtigen Lösungen“ und einem gewissen Besitzdenken hinsichtlich des geschriebenen Codes äußert. Nicht alle Programmierer können damit umgehen, dass – gemäß XP – jeder den Code aller anderen modifizieren darf.
    XP weist eine Reihe von Merkmalen auf, die hohe Disziplin erfordern (wie z. B. der Test-first-Ansatz, das permanente Durchführen von Refactorings, Programmieren in Paaren usw.), und einige andere, die eine gewisse Disziplinlosigkeit fördern (z. B. das Auslassen von Spezifikation und Dokumentation). Es besteht die Gefahr, dass die letzteren Ansätze gegenüber den Ersteren betont werden. Die Einhaltung der Ansätze mit hoher Disziplin erfordert fähige Beteiligte und eine funktionierende Selbstregulierung des Teams. Da aber unter Umständen kein Projektverantwortlicher benannt wurde, fragt sich, wer letztlich für die konsequente Einhaltung aller Aspekte sorgt.

Die Anforderungen zeigen, dass XP nicht auf beliebige Teams angewandt werden kann.
Beschränkte Team- und damit Projektgröße

Mehrere XP-Methoden erfordern einen hohen Grad an gegenseitiger Informiertheit und somit ein hohes Maß an Kommunikation zwischen den Beteiligten. So bedingt das kontinuierliche Refactoring unter Umständen Änderungen gemeinsam genutzter Komponenten, über die möglichst das gesamte Team unterrichtet sein muss. Das Fehlen eines Projektmanagers erfordert gemeinsame Absprachen zur Arbeitsteilung. Da zudem eine präzise Spezifikation und Dokumentation fehlt, müssen alle Informationen zur Umsetzung „in den Köpfen“ der Beteiligten verfügbar sein. Mit der Größe des Teams steigt jedoch der Kommunikationsaufwand quadratisch an, so dass XP-Projekten eine natürliche Grenze hinsichtlich der Teamgröße gesetzt ist. Die maximale Größe wird gemeinhin bei 10 Teammitgliedern angesetzt.
Fehlende Eignung für Festpreisprojekte

Ein weiterer häufiger Kritikpunkt ist, dass XP für Festpreisprojekte nicht geeignet sei. Da der Kunde einen festen Preis zahlt, muss der Auftragnehmer in irgendeiner Form sicherstellen, dass er für diesen Preis auch nur eine festgelegte Leistung erbringen muss. Die Leistungserbringung so lange, „bis der Kunde zufrieden ist“, kann in immer neuen Kundenanforderungen münden, so dass die Aufwände für die Realisierung nicht abzusehen sind. Die Festlegung der Festleistung als Inhalt des Werkvertrages entspräche jedoch einer Spezifikation und ist somit in XP verpönt. Es gibt einige Ansätze, XP dennoch mit Festpreisprojekten kompatibel zu machen:

    Versicherungsprämien auf die Schätzung
    User-Storys (bzw. die Story-Cards) werden zum Vertragsgegenstand
    besondere Preismodelle wie Aufwandspreis mit Obergrenze, Phasenfestpreis oder Anforderungseinheitspreis.

Die Wirksamkeit dieser Ansätze ist jedoch unklar. User-Storys können zu unpräzise sein, um das Gewerk gegen unerwartete technische Anforderungen abzusichern. Die angesprochenen Preismodelle entsprechen nur noch bedingt einem Festpreis und damit Werkvertrag, so dass fraglich ist, ob ein Kunde mit der Vorgabe eines Festpreises darauf eingehen würde. Selbiges gilt auch für Versicherungsprämien.
Feste Fertigstellungstermine

Die iterative Vorgehensweise von XP und der fehlende Projektplan legen bereits nahe, dass die Fertigstellung eines fachlich gewünschten Funktionsumfangs zu einem gesetzten Termin nicht ohne weiteres garantiert werden kann. Zwar wird zu dem gesetzten Termin etwas fertig sein (da der Fokus jeder Iteration auf einer ausführbaren, ggf. sogar produktionsfähigen Software liegt), welche fachlichen Aspekte dies jedoch tatsächlich sind, kann nicht vorherbestimmt werden – umso weniger als Überstunden verpönt sind und das Ausmaß nötiger Refactorings auf Grund beweglicher Anforderungen nur schwer abgeschätzt werden kann.
Einsatz in verteilten Umgebungen

XP gilt in verteilten Umgebungen als schwerer einsetzbar als herkömmliche Modelle. Der direkte Kontakt der Entwickler untereinander und zum Kunden ist problematisch, falls verschiedene Kunden existieren oder die Beteiligten räumlich getrennt arbeiten, so zum Beispiel bei teilweise ausgelagerten Entwicklungen (Outsourcing).
Kritik an einzelnen Praktiken

Die stets erneute Erstellung von Testfällen und die automatisierte, permanente Ausführung der Tests kann in komplexen oder nebenläufigen Anwendungen und verteilten Systemen aufwändig sein. Wenn sich keine Rollen ausbilden, muss jeder alles wissen, statt einzelne Schwerpunkte im Team zu setzen (klassisches Beispiel: GUI-Entwicklung und Datenbank-Entwicklung), was die Gesamtleistung des Teams vermindern kann.
Personalpolitik

Da das Team im Vordergrund steht, dürfen einzelne Entwickler nicht nach dem Umfang ihrer entwickelten Funktionalität honoriert werden. Insbesondere der Honorarvertrag ist kein geeignetes Vergütungsmodell bei Anwendung des Vorgehensmodells der XP.